### 简介

number是JavaScript基本类型之一

ES6中提供了新的八进制，十六进制数值表示方法，但是我们基本不会用到，下面将不会介绍这一知识点

ES6主要对Math对象做了一些扩展，新增了一些和数学关系密切的API

### 正文

在ES6以前，我们使用isNaN这个全局方法判断一个值或者变量是否是NaN

ES6中，Number对象上也添加了isNaN方法,并且与以前的isNaN有重要的区别

```javascript
isNaN(NaN) // true
isNaN("NaN") // true
Number.isNaN(NaN) // true
Number.isNaN("NaN") // false
```

显然，以前的isNaN方法在判断之前，先对不是number类型的"NaN"做了隐式转换，变成了NaN，而Number.isNaN不会转换

可以简单的理解成 == 和 === 的区别

和isNaN类似，isFinite方法也被添加到Number对象上，而且判断也变得严格了

还有一些全局方法也被添加到Number对象上，但是使用起来没有任何变化，这里不做介绍

ES6在Number对象上面，新增了一些常量，如js能表达的最大值和最小值等

我们不必关心这些，正常书写代码不会用到，不过我们需要注意一个关于小数运算的问题

```javascript
0.1 + 0.2
// 0.30000000000000004
```

为什么会不准确？ 

这是因为一些有限小数转化成二进制却是无限循环，js解析器只能取一个近似值来做计算，所以得到的结果也有偏差

ES6新增了一个常量 `Number.EPSILON` 来表示小数运算时的误差范围

ES6在Math对象上新增了17个与数学相关的方法，比如三角函数，对数，幂运算等等，需要用到的时候查阅文档即可

另外，ES7中新增了一个指数运算符（`**`）

```javascript
2 ** 2 // 4
2 ** 3 // 8
```

### 思考
**这部分内容希望你都可以手动敲一遍，独立思考**

```javascript
Number.isNaN(15) 
Number.isNaN('15') 
Number.isNaN(true) 
Number.isNaN(9/NaN) 
Number.isNaN('true'/0) 
Number.isNaN('true'/'true') 
```
上面的代码分别都输出什么？

对隐式转换熟悉吗？不熟悉的话不如Google一下，这个概念很重要

ES6中把一些全局方法加到Number对象上了，即使他们没有任何变化，这样做有什么好处？

---

```javascript
0.1 + 0.2
// 0.30000000000000004
```
如何让上面的小数运算变的精准？

试试写出一个函数，它接收两个参数，并返回他们精准的和，无论这两个参数是否是小数

---

```javascript
Math.pow(99, 99)
// 3.697296376497263e+197

99 ** 99
// 3.697296376497268e+197
```

注意结果的最后一位不同，猜猜为什么？

---

- [上一章：字符串](string.md)
- [下一章：数组](array.md)
